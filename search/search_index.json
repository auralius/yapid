{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"YAPID (Yet Another PID Library for Arduino) About YAPID YAPID is another PID library for Arduino, In YAPID, we emphasize more accurate implementations through detailed discretization techniques and result comparisons against MATLAB Simulink . Details on the PID implementation are as follows: Bilinear transform (trapezoidal or Tustin) method for the discretization technique A derivative filter for the derivative term of the PID control Simple integral windup prevention method with clamping technique Besides PID, YAPID also has two low-pass filter implementations: 1st order (time constant) low-pass filter 2nd order (Butterworth) low-pass filter Author(s) information: Auralius Manurung - Universitas Telkom, Bandung \u2709 auralius.manurung@ieee.org Control algorithm derivations YAPID uses bilinear transform to discretize both the PID and the filter transfer functions. Additionally, YAPID also has a clamping method implemented to prevent the integrator windup. Mathematical details can be found in the following links: Digital PID Control - Part 1 Digital PID Control - Part 2 Digital Low-Pass Filter How to use YAPID These are the main functions that we can use: float YAPID::Compute0(float set_value, float process_value) This simply sends set_value as control output. There is no feedback control happening here. This function is useful to testing system's open-loop respose. float YAPID::Compute1(float set_value, float process_value) D-term is computed from the filtered errors. With derivative kicks. Simple integral windup prevention with clamping technique. float YAPID::Compute2(float set_value, float process_value) D-term is computed from the filtered process values. No derivative kicks. Simple integral windup prevention with clamping technique . float YAPID::FOLP(float tau, float in) First-order low-pass filter (time-constant filter). float YAPID::SOLP(float tau, float in) Second-order low-pass filter (Butterworth filter). YAPID DOES NOT measure the elapsed time every iteration. It simply uses the provided sampling time during the setup. Therefore, to guarantee control determinism, it is easier if we use a timer interrupt handler to run the control periodically. All provided examples use timer interrupts. To use YAPID library, first, we need to include the header file: #include \"yapid.h\" Next, we create a global YAPID object and several global variables: // Create the PID controller float kp = 100.; // kp float ki = 10.0; // ki float kd = 1.0; // kd float N = 1.0; // derivative filter coefficient (Hz) float Ts = 1e-3; YAPID pid(Ts, kp, ki, kd, N); Within the Arduino's setup() function, we define the limits for the control's output. The default limit is 0.0 \\leq \\text{CO} < 255.0 . Since we use a timer interrupt, we setup out timer interrupt also in this setup() function. #define TIMER2_INTERVAL_MS 1 // 1kHz void setup() { // Setup the timer interrupt (we use NANO, timer-1, and // https://github.com/khoih-prog/TimerInterrupt) ITimer1.init(); ITimer1.attachInterruptInterval(TIMER1_INTERVAL_MS, Timer1Handler); // Define the control output limits // Here, the output becomes PWM signals (0 to 255) pid.SetOutputLimits(0., 255) // ... // ... } Finally, in the timer interrupt function handler, we can put our PID control. The steps are: * read the sensor ( pv ) * compute the PID ( co ) * apply the output to the actuator/plant * measure the elapsed time void Timer1Handler() { float pv = (float)analogRead(A0) * 5.0 / 1024.0; float co = pid.Compute1(SV, pv); analogWrite(pwm_port, (int)co); pid.UpdateTime(); } Examples with comparisons to MATLAB Simulink RC-system Here, our task is to use YAPID to control v_c(t) by modulating v_i(t) . The following code listing is the Arduino Nano's implementation where we set K_p=100 , K_i=100 , K_d=10 , and N=100 . The PID control is executed periodically (every 1 ms or 1kHz) by Timer-1. #define TIMER_INTERRUPT_DEBUG 0 #define _TIMERINTERRUPT_LOGLEVEL_ 0 #define USE_TIMER_1 true #include \"TimerInterrupt.h\" #include \"yapid.h\" #define TIMER1_INTERVAL_MS 1 const int pwm_port = 3; // TIMER-2 // Create the PID controller float kp = 100.; // kp float ki = 100.0; // ki float kd = 10.0; // kd float N = 100.0; // derivative filter constant (Hz) float Ts = 1e-3; YAPID pid(Ts, kp, ki, kd, N); volatile float SV = 0.0; // set value //------------------------------------------------------------------ void setup() { ITimer1.init(); ITimer1.attachInterruptInterval(TIMER1_INTERVAL_MS, Timer1Handler); pinMode(pwm_port, OUTPUT); analogWrite(pwm_port, 0); pid.SetOutputLimits(0., 255.) ; Serial.begin(1000000); } void rx() { while(Serial.available()){ int StringCount = 0; String input = Serial.readString(); SV = input.toFloat(); } } inline void tx() { Serial.print(pid.Now(), 3); Serial.print(\",\"); Serial.print(pid.SV()); Serial.print(\",\"); Serial.print(pid.PV()); Serial.print(\",\"); Serial.print(pid.P()); Serial.print(\",\"); Serial.print(pid.I()); Serial.print(\",\"); Serial.print(pid.D()); Serial.print(\",\"); Serial.print(pid.CO()); Serial.print(\",\"); Serial.print(pid.SAT_CO()); Serial.print(\"\\n\"); } void Timer1Handler() { float pv = (float)analogRead(A0) * 5.0 / 1024.0; float co = pid.Compute1(SV, pv); analogWrite(pwm_port, (int)co); pid.UpdateTime(); } void loop() { // Serial receive rx(); // Serial transmit tx(); if (pid.Now() < 15.0) SV = 0.0; else if ((pid.Now() > 15.0) && (pid.Now() < 30.0)) SV = 4.0; else if (pid.Now() > 30.0) SV = 1.0; } The next figure shows similar implementation in MATLAB Simulink with identical control parameters. For this, we use the Simulink\u00ae Support Package for Arduino\u00ae . The Simulink file can be downloaded here (R2024b) Finally, the results are shown in the following plots. As shown by the plots, YAPID gives results that is very close to MATLAB Simulink. DC-motor position control (with potentiometer) DC-motor control (with quadrature encoder) Heater control","title":"YAPID (Yet Another PID Library for Arduino)"},{"location":"#yapid-yet-another-pid-library-for-arduino","text":"","title":"YAPID (Yet Another PID Library for Arduino)"},{"location":"#about-yapid","text":"YAPID is another PID library for Arduino, In YAPID, we emphasize more accurate implementations through detailed discretization techniques and result comparisons against MATLAB Simulink . Details on the PID implementation are as follows: Bilinear transform (trapezoidal or Tustin) method for the discretization technique A derivative filter for the derivative term of the PID control Simple integral windup prevention method with clamping technique Besides PID, YAPID also has two low-pass filter implementations: 1st order (time constant) low-pass filter 2nd order (Butterworth) low-pass filter Author(s) information: Auralius Manurung - Universitas Telkom, Bandung \u2709 auralius.manurung@ieee.org","title":"About YAPID"},{"location":"#control-algorithm-derivations","text":"YAPID uses bilinear transform to discretize both the PID and the filter transfer functions. Additionally, YAPID also has a clamping method implemented to prevent the integrator windup. Mathematical details can be found in the following links: Digital PID Control - Part 1 Digital PID Control - Part 2 Digital Low-Pass Filter","title":"Control algorithm derivations"},{"location":"#how-to-use-yapid","text":"These are the main functions that we can use: float YAPID::Compute0(float set_value, float process_value) This simply sends set_value as control output. There is no feedback control happening here. This function is useful to testing system's open-loop respose. float YAPID::Compute1(float set_value, float process_value) D-term is computed from the filtered errors. With derivative kicks. Simple integral windup prevention with clamping technique. float YAPID::Compute2(float set_value, float process_value) D-term is computed from the filtered process values. No derivative kicks. Simple integral windup prevention with clamping technique . float YAPID::FOLP(float tau, float in) First-order low-pass filter (time-constant filter). float YAPID::SOLP(float tau, float in) Second-order low-pass filter (Butterworth filter). YAPID DOES NOT measure the elapsed time every iteration. It simply uses the provided sampling time during the setup. Therefore, to guarantee control determinism, it is easier if we use a timer interrupt handler to run the control periodically. All provided examples use timer interrupts. To use YAPID library, first, we need to include the header file: #include \"yapid.h\" Next, we create a global YAPID object and several global variables: // Create the PID controller float kp = 100.; // kp float ki = 10.0; // ki float kd = 1.0; // kd float N = 1.0; // derivative filter coefficient (Hz) float Ts = 1e-3; YAPID pid(Ts, kp, ki, kd, N); Within the Arduino's setup() function, we define the limits for the control's output. The default limit is 0.0 \\leq \\text{CO} < 255.0 . Since we use a timer interrupt, we setup out timer interrupt also in this setup() function. #define TIMER2_INTERVAL_MS 1 // 1kHz void setup() { // Setup the timer interrupt (we use NANO, timer-1, and // https://github.com/khoih-prog/TimerInterrupt) ITimer1.init(); ITimer1.attachInterruptInterval(TIMER1_INTERVAL_MS, Timer1Handler); // Define the control output limits // Here, the output becomes PWM signals (0 to 255) pid.SetOutputLimits(0., 255) // ... // ... } Finally, in the timer interrupt function handler, we can put our PID control. The steps are: * read the sensor ( pv ) * compute the PID ( co ) * apply the output to the actuator/plant * measure the elapsed time void Timer1Handler() { float pv = (float)analogRead(A0) * 5.0 / 1024.0; float co = pid.Compute1(SV, pv); analogWrite(pwm_port, (int)co); pid.UpdateTime(); }","title":"How to use YAPID"},{"location":"#examples-with-comparisons-to-matlab-simulink","text":"","title":"Examples with comparisons to MATLAB Simulink"},{"location":"#rc-system","text":"Here, our task is to use YAPID to control v_c(t) by modulating v_i(t) . The following code listing is the Arduino Nano's implementation where we set K_p=100 , K_i=100 , K_d=10 , and N=100 . The PID control is executed periodically (every 1 ms or 1kHz) by Timer-1. #define TIMER_INTERRUPT_DEBUG 0 #define _TIMERINTERRUPT_LOGLEVEL_ 0 #define USE_TIMER_1 true #include \"TimerInterrupt.h\" #include \"yapid.h\" #define TIMER1_INTERVAL_MS 1 const int pwm_port = 3; // TIMER-2 // Create the PID controller float kp = 100.; // kp float ki = 100.0; // ki float kd = 10.0; // kd float N = 100.0; // derivative filter constant (Hz) float Ts = 1e-3; YAPID pid(Ts, kp, ki, kd, N); volatile float SV = 0.0; // set value //------------------------------------------------------------------ void setup() { ITimer1.init(); ITimer1.attachInterruptInterval(TIMER1_INTERVAL_MS, Timer1Handler); pinMode(pwm_port, OUTPUT); analogWrite(pwm_port, 0); pid.SetOutputLimits(0., 255.) ; Serial.begin(1000000); } void rx() { while(Serial.available()){ int StringCount = 0; String input = Serial.readString(); SV = input.toFloat(); } } inline void tx() { Serial.print(pid.Now(), 3); Serial.print(\",\"); Serial.print(pid.SV()); Serial.print(\",\"); Serial.print(pid.PV()); Serial.print(\",\"); Serial.print(pid.P()); Serial.print(\",\"); Serial.print(pid.I()); Serial.print(\",\"); Serial.print(pid.D()); Serial.print(\",\"); Serial.print(pid.CO()); Serial.print(\",\"); Serial.print(pid.SAT_CO()); Serial.print(\"\\n\"); } void Timer1Handler() { float pv = (float)analogRead(A0) * 5.0 / 1024.0; float co = pid.Compute1(SV, pv); analogWrite(pwm_port, (int)co); pid.UpdateTime(); } void loop() { // Serial receive rx(); // Serial transmit tx(); if (pid.Now() < 15.0) SV = 0.0; else if ((pid.Now() > 15.0) && (pid.Now() < 30.0)) SV = 4.0; else if (pid.Now() > 30.0) SV = 1.0; } The next figure shows similar implementation in MATLAB Simulink with identical control parameters. For this, we use the Simulink\u00ae Support Package for Arduino\u00ae . The Simulink file can be downloaded here (R2024b) Finally, the results are shown in the following plots. As shown by the plots, YAPID gives results that is very close to MATLAB Simulink.","title":"RC-system"},{"location":"#dc-motor-position-control-with-potentiometer","text":"","title":"DC-motor position control (with potentiometer)"},{"location":"#dc-motor-control-with-quadrature-encoder","text":"","title":"DC-motor control (with quadrature encoder)"},{"location":"#heater-control","text":"","title":"Heater control"}]}